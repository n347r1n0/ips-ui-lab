# React + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react) uses [Babel](https://babeljs.io/) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## Expanding the ESLint configuration

If you are developing a production application, we recommend using TypeScript with type-aware lint rules enabled. Check out the [TS template](https://github.com/vitejs/vite/tree/main/packages/create-vite/template-react-ts) for information on how to integrate TypeScript and [`typescript-eslint`](https://typescript-eslint.io) in your project.








# FloatingChipWheel — план улучшений (актуализированный)

## P1 · UX-полировка (ощущение и отклик)

* [x] Мягкий **щелчок-снап**

  * **Что:** короткий haptic/звук при фиксации выбора + лёгкий `scale` активной ячейки.
  * **Как (сейчас):** haptics после первого тапа; звук синтез через Web Audio (без файлов), мгновенный старт; вызов на `snapTo`.
  * **Осталось:** при желании добавить микро-pulse активной иконке (`scale 1.06–1.10`, `120–160ms ease-out`) — без изменения хит-зоны.
  * **Готово когда:** отклик не наслаивается при быстрых сериях; нет «раздутия» хит-зоны.

* [x] **Tick** при проходе секций (dial-эффект)

  * **Что:** тихий «тик» при пересечении целого шага во время драга.
  * **Как (сейчас):** синтезированный звук `tick` с анти-спамом (`cooldown`), без вибро.
  * **Готово когда:** нет «рассыпания» кликов при очень быстром свайпе; частота тиков предсказуема.

* [x] Регулировка **громкости** (надёжная)

  * **Что:** глобальный `soundMaster` + платформенная аттенюация iOS; раздельные уровни `snap/tick`.
  * **Как (сейчас):** master gain + пересчёт уровней при изменении пропсов, без лишних пересозданий AudioContext.
  * **Готово когда:** на iOS ощущается тише/мягче, на Android/desktop — без перегруза.

* [ ] **Дуга-индикатор** при драге

  * **Что:** тонкая «наводка» (conic-gradient) в центральной зоне; мягкие fade-in/out.
  * **Как:** отдельный слой с `opacity` и отключением при `!startedRef`.
  * **Готово когда:** без рывков, не перекрывает иконки, не влияет на FPS.

* [ ] **Кликабельная подпись** секции (Label → меню)

  * **Что:** тап по лейблу открывает компактный список секций; выбор → локальный снап и закрытие.
  * **Как:** локальный popover (портал, `z-50`), клики снаружи закрывают; на время меню свайп колеса блокируется.
  * **Готово когда:** нет конфликтов со свайпом; меню отзывчиво; выбор предсказуем.

* [ ] **Акцент-кольцо** под активной иконкой

  * **Что:** чёткое тонкое золотое кольцо вместо/поверх «размытого halo».
  * **Как:** в `decorateIcon` слой `radial-gradient(closest-side, ...)` с параметрами через `skinProps`.
  * **Готово когда:** нет алиасинга/дрожания на «шве», толщина настраивается.

---

## P1.5 · Системные жесты и края экрана (iOS/Android Web)

* [ ] Политика жестов: `gesturePolicy: 'greedy' | 'polite' | 'edge-safe'` (дефолт `edge-safe`)

  * **Что:** предсказуемая конкуренция с системными жестами.
  * **Как:** управление `touch-action`, deadzone, `setPointerCapture` в зависимости от режима.
  * **Готово когда:** разница режимов заметна и помогает под устройство.

* [ ] **Edge-safe зона**

  * **Что:** не стартовать drag в охранной зоне краёв; разрешать `tap-hold→drag`.
  * **Как:** учитывать `env(safe-area-inset-*)` + `edgeGuardPx`.
  * **Готово когда:** back-swipe/home-indicator не конфликтуют.

* [ ] **Back-swipe iOS (левый край)**

  * **Что:** уважать системный жест «назад».
  * **Как:** при `clientX < edgeBackSwipePx` блокировать drag до `pointerup`, разрешая tap.
  * **Готово когда:** back-swipe стабильно работает.

* [ ] **Pull-to-refresh / overscroll**

  * **Что:** не допускать P2R во время drag.
  * **Как:** на время drag `overscroll-behavior: none` + возврат после.
  * **Готово когда:** нет «отскоков» / P2R при активном перетаскивании.

* [ ] **Динамический вьюпорт (iOS адресная строка)**

  * **Что:** колесо не «прыгает» при показе/скрытии браузерного UI.
  * **Как:** `visualViewport` + `dvh` + учёт `safe-area-inset-bottom` в `offset`.
  * **Готово когда:** позиция стабильна.

* [ ] **Auto-offset от home-indicator**

  * **Что:** смещение от нижнего дока/индикатора.
  * **Как:** если `dock` снизу — добавлять `env(safe-area-inset-bottom) + marginPx`.
  * **Готово когда:** хит-зона не утыкается в системный элемент.

* [ ] **Tap-hold→drag** (fallback)

  * **Что:** вежливый запуск drag после удержания.
  * **Как:** таймер 120–180мс до активации drag в охранной зоне.
  * **Готово когда:** жесты стартуют надёжно вблизи краёв.

* [ ] **Матрица регресса по жестам**

  * **Что:** чек-лист: iOS Safari (back-swipe, адресная строка), Android Chrome (P2R), Firefox mobile, Desktop touch.
  * **Готово когда:** сценарии воспроизводимы и быстро проверяются.

---

## P2 · Визуал/скины

* [ ] Стеклянная палитра → токены

  * **Что:** `--chip-glass-*`, blur, интенсивности.
  * **Как:** вынести из JSX в `tokens.css`.
  * **Готово когда:** скины крутятся темой без правок кода.

* [ ] Настройка «визуальных клиньев»

  * **Что:** `visualWedgeDeg` (дефолт = `stepDeg`) для независимой частоты узора.
  * **Как:** не ломая фазировку и «шов».
  * **Готово когда:** узор стабилен на любом значении.

* [ ] Лёгкий anti-bleed

  * **Что:** микросмещение/оверлап клиньев `0.5–1°` + аккуратные разделители.
  * **Как:** через `overlapDeg`/разделители в скине.
  * **Готово когда:** нет «просветов» на ретине/масштабе.

* [ ] Периметр активного клина — **отложено**

  * **Что:** тонкий контур по всему сектору.
  * **Как:** conic-mask + дуги; пока не делаем.

---

## P2 · Надёжность/синхронизация

* [ ] «Единый источник правды» в API

  * **Что:** развести `onSnapCommit(id)` (момент пользовательского выбора) и `onExternalSync(id)` (подвод к внешнему).
  * **Как:** сейчас `onSelect` вызывается в `snapTo` (старт анимации), внешние апдейты игнорим во время интеракции/settle — это сохранить.
  * **Готово когда:** внешние апдейты не фликают, а хук выбора приходит ровно один раз.

* [ ] Тест-матрица «шва»

  * **Что:** автопроверки для разных `stepDeg` (кратно/некратно 360), `dock`, DPR.
  * **Готово когда:** визуальные артефакты не воспроизводятся.

---

## P3 · Доступность

* [ ] Полная ARIA-навигация

  * **Что:** `role="tablist"` у колеса, `role="tab"` у иконок, `aria-selected`, клавиши `←/→/Enter/Escape`.
  * **Как:** отложено (по твоей просьбе).
  * **Готово когда:** WCAG-навигация без мыши проходит.

* [ ] Reduced-motion дружелюбность

  * **Что:** все анимации учитывают `prefers-reduced-motion`.
  * **Как:** глобально RMP уже снижает длительности; точечно проверить snap/tick/pulse.
  * **Готово когда:** переходы мгновеннее на RMP, без «дёрганий».

---

## P3 · Производительность/Dev-опыт

* [ ] Безопасные градиенты

  * **Что:** максимум 3–4 слоя conic/radial; не плодить DOM «на сектор».
  * **Готово когда:** FPS стабилен на бюджетных девайсах.

* [ ] Playground для скинов

  * **Что:** мини-страница с лайв-регуляторами (`stepDeg`, `phaseDeg`, альфы стекла).
  * **Готово когда:** «шов»/фазировка диагностируются за 10 секунд.

---

### Примечания к текущему состоянию

* Стабильный пресет: `stepDeg = 36` (чётное число визуальных клиньев) + фазировка через `phaseDeg`.
* Узор и иконки синхронизированы одной фазой: `phase = center + phaseDeg − stepF * stepDeg`.
* Акцент активной ячейки: золотая подложка-halo + лёгкий `scale` (глиф — белый).
* Звук: синтез Web Audio (tick/snap), `soundMaster` + iOS-аттенюация, без аудиофайлов.
* Внешняя синхронизация: во время взаимодействия/settle — лок приоритета «экрана» сохранён.

---

Если ок — перейдём к «кликабельной подписи» и я кратко (в 5–7 пунктов) опишу целевой UX и минимальные изменения в коде/структуре (без кода в этом шаге).


















# Спецификация: Accordion-dropdown для FloatingChipWheel

## Контекст

Компонент: `frontend/src/ui/patterns/FloatingChipWheel.jsx`.

Внутри компонента уже есть три режима меню:

* `panel` (большая панель, текущий вариант),
* `compact` (узкая системная),
* **`accordion` (НУЖНО СДЕЛАТЬ)** — «пилюля» всегда на месте, при клике **та же пилюля** аккуратно расширяется в список, как аккордеон.

Сейчас «аккордеон» не работает по замыслу: создаётся вторая «копия» пилюли поверх. Нам нужно ровно обратное — **один и тот же DOM-элемент пилюли**, а список «вырастает» из него вверх/вниз.

---

## Цель / UX-идея

1. **Пилюля с текущей секцией отображается всегда** (до клика), внутри неё сразу есть **название секции** (и иконка — см. ниже).
2. По клику на пилюлю она **раскрывается аккордеоном**: над ней (если виджет у нижней кромки) или под ней (если виджет у верхней кромки) появляется компактный список остальных секций.
3. **Пилюля остаётся на месте** (никаких дубликатов/оверлеев).
4. Список содержит **все остальные** секции (кроме активной), упорядоченные как в `compact` (по умолчанию: clockwise, начиная со следующей).
5. При выборе пункта — хлёсткая «доводка» (наш `snapTo` уже делает) и закрытие списка.
6. Анимация — быстрый, опрятный **аккордеон**: `max-height + opacity + scaleY(0.96→1)`.

---

## Поведение по пропсам (используем уже существующие)

* Включение режима: `labelMenuVariant="accordion"`.
* Направление раскрытия: `compactDirection: 'up' | 'down' | 'auto'`
  `auto`: ориентируемся на текущий `anchor.ty` (как в compact):

  * если колесо докнуто снизу (`ty = +1`) — **открываем вверх**,
  * если сверху (`ty = -1`) — **вниз**.
* Отступ между пилюлей и списком: `compactGutter` (px).
* Высота строки: `compactItemHeight` (px).
* Кол-во элементов: `compactMaxItems` (по умолчанию 6; при `Infinity` — все).
* Порядок: `compactOrder` ('clockwise' | 'original').
* Список формируется так же, как `compactItems` (т.е. «все, кроме активной»).

---

## Визуальный спек (аккордеон)

* **Пилюля** (не меняем стилизацию, только гарантируем присутствие иконки):

  * Вид: тот же, что и сейчас для подписи (soft glass + тонкая рамка).
  * Содержимое: **иконка активной секции + название**.
    Иконка **всегда видима** в аккордеоне (не только при открытии).
  * При клике — лёгкий «pulse»/highlight.
* **Список**:

  * Одна колонка, **плотные** строки: `px-3`, `height = compactItemHeight`.
  * Внутри: иконка 16px (`w-4 h-4`) + однострочный label (truncate/nowrap).
  * Контейнер: скруглённый, стеклянный, с рамкой и тенью (как в compact).
  * Появляется **над** пилюлей (`up`) или **под** пилюлей (`down`).
  * Между списком и пилюлей — `compactGutter` (px).
  * Максимальная высота: `accordionListMaxH = rows * compactItemHeight`.
    `rows = min(compactItems.length, compactMaxItems)`.
  * Анимация открытия/закрытия:

    * `max-height: 0 → accordionListMaxH`,
    * `opacity: 0 → 1`,
    * `transform: scaleY(0.96) → scaleY(1)`,
    * `transition: 150–180ms ease`.
* **Фокус/hover**: подсветка строки на hover/focus, как в остальных меню.

---

## Архитектура / Где рендерить

* **В аккордеоне список рендерится рядом с пилюлей** ВНУТРИ блока «Подпись» (center label).
  Это ключевое: **никаких отдельностоящих абсолютных блоков** поверх центра, чтобы не было второй «копии» пилюли.
* Варианты `panel` и `compact` **оставляем как есть** — они продолжают рендериться в отдельной ветке.
  В аккордеоне отдельной ветки меню **не должно быть** — весь UI живёт внутри пилюли.

---

## Логика/Состояния

* Используем текущие `isMenuOpen`, `openMenu/closeMenu`, `handleLabelClick`, обработчики клика вне / Esc — **без регрессий**.
  Важно: `menuRef` должен оборачивать **весь «пакет аккордеона»** (список + пилюля), чтобы клик «вне» корректно закрывал.
* Выбор элемента:

  * На клик пункта находим индекс в `clean`, вызываем `handleMenuItemClick(idx)` — как сейчас.
  * Внутри `handleMenuItemClick`: закрываем меню и делаем `snapTo(...)`.
* Порядок пунктов: **как в `compact`** (`compactItems`).

---

## Доступность (A11y)

* Пилюля — `<button>`:

  * `aria-expanded={isMenuOpen}`,
  * `aria-controls={menuId}`,
  * `aria-haspopup="listbox"` (или `menu` — можно оставить, но для выбора опций `listbox` ближе).
* Список — контейнер с `role="listbox"` (или оставить `role="menu"`, но тогда придерживаемся меню-паттерна).
  Элементы — `role="option"` (`menuitem`, если остаёмся на меню-паттерне).
* Клавиатура:

  * `Enter/Space` на пилюле — открыть/закрыть.
  * В открытом списке: `ArrowUp/ArrowDown` двигают фокус между опциями (можно простым `tabIndex` + ловля keydown), `Enter` — выбрать.
  * `Esc` — закрыть.
* Фокус видим, таб-навигация линейная, `aria-label` у пилюли: `"Current section: <title>. Expand/Collapse list"`.

---

## Производительность

* Аккордеон нельзя делать через автолейаут с перерасчётом большого DOM.
  Переходы — через `max-height` + `opacity` + `scaleY`; **никаких heavy layout thrash**.
* Не создаём дубль дерева «пилюли».

---

## Краевые кейсы

* Очень длинное название активной секции — `truncate` внутри пилюли, не ломаем геометрию.
* Много пунктов — `max-height` + прокрутка списочного контейнера.
* `compactDirection='auto'`:

  * если виджет снизу (текущий `anchor.ty === +1`) — раскрывать **вверх**,
  * если сверху — **вниз**.
* Если экран перевёрнут/resize — направление остаётся исходным на время открытия; на следующее открытие — пересчёт (как сейчас в compact).
* В момент свайпа по колесу — клики по пилюле игнорируем (у нас уже есть блокировку на `draggingRef/animating`).

---

## Пошаговая реализация (важно следовать очередности)

1. **Вписать название секции в пилюлю «всегда»**:

   * Пилюля всегда показана в центре, содержит **иконку+label** активной секции.
   * Для аккордеона иконка **всегда видима** (не только при открытии).
2. **Сделать пилюлю кликабельной**:

   * Клик → `isMenuOpen = !isMenuOpen`.
   * Ветка аккордеона использует те же хэндлеры закрытия по клику вне/ESC.
3. **Добавить список, «растущий» из пилюли**:

   * Рендер рядом с пилюлей (в одном блоке).
   * Позиция: вверх/вниз (**без абсолютного позиционирования на весь центр**).
   * Отступ до пилюли = `compactGutter`.
   * Список = `compactItems` (все, кроме активной, порядок как в compact).
4. **Анимация аккордеона**:

   * Переходы как описано (max-height/opacity/scaleY).
   * Скорость ~150–180ms ease (можно reuse `transition-150`).
5. **Клавиатура / a11y**:

   * `aria-expanded`, `aria-controls`, `role="listbox"`/`option` или оставить `menu/menuitem` (но последовательно).
   * Up/Down/Enter/Esc.
6. **Не трогаем** рендер `panel` и `compact` (они живут в своём условии и не конфликтуют с `accordion`).

---

## Критерии приёмки (acceptance)

* В `labelMenuVariant="accordion"`:

  * До клика видно **одну** пилюлю с иконкой+названием активной секции.
  * По клику список **появляется из пилюли**, в правильном направлении (вверх/вниз по `compactDirection/auto`).
  * В DOM **нет второй пилюли**, не накладывается поверх.
  * При выборе пункта — список закрывается, колесо снапается на выбранную секцию, пилюля обновляет текст/иконку.
  * Закрытие по клику вне и по `Esc` работает.
  * Анимация — плавная, без «дёрганий», без скачков позиции пилюли.
* `panel` и `compact` ведут себя как раньше.

---

## Подсказки по внедрению (нужные куски из текущей логики)

* **Направление** можно брать из того же вычисления, что и для compact (`compactDir` на базе `anchor.ty`).
* **Список** — использовать `compactItems`.
* **Выбор** — `handleMenuItemClick()` уже делает правильный `snapTo` + закрытие.
* **Закрытие вне** — `menuRef` должен оборачивать **пилюлю и список** внутри аккордеона, чтобы клик по пилюле считался «внутренним».

