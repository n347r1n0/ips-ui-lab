# React + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react) uses [Babel](https://babeljs.io/) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## Expanding the ESLint configuration

If you are developing a production application, we recommend using TypeScript with type-aware lint rules enabled. Check out the [TS template](https://github.com/vitejs/vite/tree/main/packages/create-vite/template-react-ts) for information on how to integrate TypeScript and [`typescript-eslint`](https://typescript-eslint.io) in your project.








# FloatingChipWheel — план улучшений (актуализированный)

## P1 · UX-полировка (ощущение и отклик)

* [x] Мягкий **щелчок-снап**

  * **Что:** короткий haptic/звук при фиксации выбора + лёгкий `scale` активной ячейки.
  * **Как (сейчас):** haptics после первого тапа; звук синтез через Web Audio (без файлов), мгновенный старт; вызов на `snapTo`.
  * **Осталось:** при желании добавить микро-pulse активной иконке (`scale 1.06–1.10`, `120–160ms ease-out`) — без изменения хит-зоны.
  * **Готово когда:** отклик не наслаивается при быстрых сериях; нет «раздутия» хит-зоны.

* [x] **Tick** при проходе секций (dial-эффект)

  * **Что:** тихий «тик» при пересечении целого шага во время драга.
  * **Как (сейчас):** синтезированный звук `tick` с анти-спамом (`cooldown`), без вибро.
  * **Готово когда:** нет «рассыпания» кликов при очень быстром свайпе; частота тиков предсказуема.

* [x] Регулировка **громкости** (надёжная)

  * **Что:** глобальный `soundMaster` + платформенная аттенюация iOS; раздельные уровни `snap/tick`.
  * **Как (сейчас):** master gain + пересчёт уровней при изменении пропсов, без лишних пересозданий AudioContext.
  * **Готово когда:** на iOS ощущается тише/мягче, на Android/desktop — без перегруза.

* [ ] **Дуга-индикатор** при драге

  * **Что:** тонкая «наводка» (conic-gradient) в центральной зоне; мягкие fade-in/out.
  * **Как:** отдельный слой с `opacity` и отключением при `!startedRef`.
  * **Готово когда:** без рывков, не перекрывает иконки, не влияет на FPS.

* [ ] **Кликабельная подпись** секции (Label → меню)

  * **Что:** тап по лейблу открывает компактный список секций; выбор → локальный снап и закрытие.
  * **Как:** локальный popover (портал, `z-50`), клики снаружи закрывают; на время меню свайп колеса блокируется.
  * **Готово когда:** нет конфликтов со свайпом; меню отзывчиво; выбор предсказуем.

* [ ] **Акцент-кольцо** под активной иконкой

  * **Что:** чёткое тонкое золотое кольцо вместо/поверх «размытого halo».
  * **Как:** в `decorateIcon` слой `radial-gradient(closest-side, ...)` с параметрами через `skinProps`.
  * **Готово когда:** нет алиасинга/дрожания на «шве», толщина настраивается.

---

## P1.5 · Системные жесты и края экрана (iOS/Android Web)

* [ ] Политика жестов: `gesturePolicy: 'greedy' | 'polite' | 'edge-safe'` (дефолт `edge-safe`)

  * **Что:** предсказуемая конкуренция с системными жестами.
  * **Как:** управление `touch-action`, deadzone, `setPointerCapture` в зависимости от режима.
  * **Готово когда:** разница режимов заметна и помогает под устройство.

* [ ] **Edge-safe зона**

  * **Что:** не стартовать drag в охранной зоне краёв; разрешать `tap-hold→drag`.
  * **Как:** учитывать `env(safe-area-inset-*)` + `edgeGuardPx`.
  * **Готово когда:** back-swipe/home-indicator не конфликтуют.

* [ ] **Back-swipe iOS (левый край)**

  * **Что:** уважать системный жест «назад».
  * **Как:** при `clientX < edgeBackSwipePx` блокировать drag до `pointerup`, разрешая tap.
  * **Готово когда:** back-swipe стабильно работает.

* [ ] **Pull-to-refresh / overscroll**

  * **Что:** не допускать P2R во время drag.
  * **Как:** на время drag `overscroll-behavior: none` + возврат после.
  * **Готово когда:** нет «отскоков» / P2R при активном перетаскивании.

* [ ] **Динамический вьюпорт (iOS адресная строка)**

  * **Что:** колесо не «прыгает» при показе/скрытии браузерного UI.
  * **Как:** `visualViewport` + `dvh` + учёт `safe-area-inset-bottom` в `offset`.
  * **Готово когда:** позиция стабильна.

* [ ] **Auto-offset от home-indicator**

  * **Что:** смещение от нижнего дока/индикатора.
  * **Как:** если `dock` снизу — добавлять `env(safe-area-inset-bottom) + marginPx`.
  * **Готово когда:** хит-зона не утыкается в системный элемент.

* [ ] **Tap-hold→drag** (fallback)

  * **Что:** вежливый запуск drag после удержания.
  * **Как:** таймер 120–180мс до активации drag в охранной зоне.
  * **Готово когда:** жесты стартуют надёжно вблизи краёв.

* [ ] **Матрица регресса по жестам**

  * **Что:** чек-лист: iOS Safari (back-swipe, адресная строка), Android Chrome (P2R), Firefox mobile, Desktop touch.
  * **Готово когда:** сценарии воспроизводимы и быстро проверяются.

---

## P2 · Визуал/скины

* [ ] Стеклянная палитра → токены

  * **Что:** `--chip-glass-*`, blur, интенсивности.
  * **Как:** вынести из JSX в `tokens.css`.
  * **Готово когда:** скины крутятся темой без правок кода.

* [ ] Настройка «визуальных клиньев»

  * **Что:** `visualWedgeDeg` (дефолт = `stepDeg`) для независимой частоты узора.
  * **Как:** не ломая фазировку и «шов».
  * **Готово когда:** узор стабилен на любом значении.

* [ ] Лёгкий anti-bleed

  * **Что:** микросмещение/оверлап клиньев `0.5–1°` + аккуратные разделители.
  * **Как:** через `overlapDeg`/разделители в скине.
  * **Готово когда:** нет «просветов» на ретине/масштабе.

* [ ] Периметр активного клина — **отложено**

  * **Что:** тонкий контур по всему сектору.
  * **Как:** conic-mask + дуги; пока не делаем.

---

## P2 · Надёжность/синхронизация

* [ ] «Единый источник правды» в API

  * **Что:** развести `onSnapCommit(id)` (момент пользовательского выбора) и `onExternalSync(id)` (подвод к внешнему).
  * **Как:** сейчас `onSelect` вызывается в `snapTo` (старт анимации), внешние апдейты игнорим во время интеракции/settle — это сохранить.
  * **Готово когда:** внешние апдейты не фликают, а хук выбора приходит ровно один раз.

* [ ] Тест-матрица «шва»

  * **Что:** автопроверки для разных `stepDeg` (кратно/некратно 360), `dock`, DPR.
  * **Готово когда:** визуальные артефакты не воспроизводятся.

---

## P3 · Доступность

* [ ] Полная ARIA-навигация

  * **Что:** `role="tablist"` у колеса, `role="tab"` у иконок, `aria-selected`, клавиши `←/→/Enter/Escape`.
  * **Как:** отложено (по твоей просьбе).
  * **Готово когда:** WCAG-навигация без мыши проходит.

* [ ] Reduced-motion дружелюбность

  * **Что:** все анимации учитывают `prefers-reduced-motion`.
  * **Как:** глобально RMP уже снижает длительности; точечно проверить snap/tick/pulse.
  * **Готово когда:** переходы мгновеннее на RMP, без «дёрганий».

---

## P3 · Производительность/Dev-опыт

* [ ] Безопасные градиенты

  * **Что:** максимум 3–4 слоя conic/radial; не плодить DOM «на сектор».
  * **Готово когда:** FPS стабилен на бюджетных девайсах.

* [ ] Playground для скинов

  * **Что:** мини-страница с лайв-регуляторами (`stepDeg`, `phaseDeg`, альфы стекла).
  * **Готово когда:** «шов»/фазировка диагностируются за 10 секунд.

---

### Примечания к текущему состоянию

* Стабильный пресет: `stepDeg = 36` (чётное число визуальных клиньев) + фазировка через `phaseDeg`.
* Узор и иконки синхронизированы одной фазой: `phase = center + phaseDeg − stepF * stepDeg`.
* Акцент активной ячейки: золотая подложка-halo + лёгкий `scale` (глиф — белый).
* Звук: синтез Web Audio (tick/snap), `soundMaster` + iOS-аттенюация, без аудиофайлов.
* Внешняя синхронизация: во время взаимодействия/settle — лок приоритета «экрана» сохранён.

---

Если ок — перейдём к «кликабельной подписи» и я кратко (в 5–7 пунктов) опишу целевой UX и минимальные изменения в коде/структуре (без кода в этом шаге).





















# Fix-pack для «кликабельной подписи» FloatingChipWheel

## Где правим

* **Только**: `frontend/src/ui/patterns/FloatingChipWheel.jsx`
* Ничего не трогаем в токенах/скинах/конфигах/страницах.

## Что уже хорошо — оставляем

* Новые пропсы: `enableLabelMenu`, `menuMaxHeight`, `onMenuOpen`, `onMenuClose`.
* Локальный стейт: `isMenuOpen`, `menuRef`, `labelRef`.
* Обработчики: открытие/закрытие, ESC, outside-click, автоскролл активного, выбор пункта через `snapTo(best)`.
* Блокировка жестов при открытом меню.

## Что нужно поправить/доделать (внести изменения в код)

### 1) pointer-events на контейнере лейбла

Сейчас обёртка лейбла у нас рендерится внутри блока с `pointerEvents: 'none'`.
**Задача:** сделать так, чтобы клики по лейблу доходили до кнопки:

* Убери `pointerEvents: 'none'` у контейнера лейбла **или** вынеси кнопку (лейбл) в обёртку, у которой `pointer-events: auto`.
* Итог: при `enableLabelMenu === true` лейбл реально кликабелен.

### 2) Убрать классы анимации из чужого набора

Мы **не** используем `animate-in`, `fade-in-0`, `zoom-in-95` (это из shadcn).
**Сделай анимацию средствами Tailwind:**

* Для поповера: состояния `opacity-0 scale-95` → `opacity-100 scale-100` с `transition-opacity transition-transform duration-150 ease-out`.
* Поддержка `prefers-reduced-motion`: при RMP не анимировать (условные классы или inline-стили — на твоё усмотрение, без новых библиотек).

### 3) Не менять/не дублировать аудио-логику

* **Не добавлять** `soundMaster` (у нас его нет).
* **Не дублировать** `audioArmedRef` (он уже есть).
* Ничего не менять в текущей звуковой/вибро-логике.

### 4) Не дублировать `renderIcon`

* В файле уже есть `renderIcon` до `return`. Не создавай вторую версию — оставь одну исходную.

### 5) Жесты: ранний выход в onEnd и безопасное открытие меню

* Там, где ты уже добавил проверки `if (animating || isMenuOpen) return`:

  * **Добавь такую же** раннюю проверку и в `onEnd`, чтобы при открытом меню не происходил `snapTo` по завершении «не начавшегося» драга.
* При **открытии меню** (в `openMenu()` или сразу в handler клика по лейблу):

  * Если шёл drag: **сбрось** `draggingRef.current = false; startedRef.current = false;` и **вызови** локальную `unlockBody()` (та, что в замыкании жестов), чтобы снять захваты/overscroll-правки. Не начинай никаких анимаций колеса.

### 6) Поповер — корректные слои и pointer-events

* Поповер должен жить в слое с `pointer-events: auto` и `z-[60]` (колесо `z-50`).
* Не помещай поповер внутрь контейнера с `pointer-events: none` или с `overflow: hidden`, чтобы не «отрезало» клики и геометрию.
* Позиционирование: абсолют от **центра колеса** (там же, где лейбл), небольшой сдвиг вверх (`translateY(-10px)`), ширина ~`w-64`, `maxHeight: menuMaxHeight`, внутренний `overflow-y-auto`.

### 7) ARIA-штрихи (без избыточности)

* На лейбл-кнопке: `role="button"`, `aria-expanded={isMenuOpen}`, `aria-haspopup="menu"`, и `aria-controls={menuId}`.
* На самом меню: стабильный `id={menuId}`.
* На пунктах: помимо `role="menuitem"`, **добавь** `aria-selected={isActive}` (оставлять `aria-current="page"` не обязательно).

### 8) Outside-click: порядок обработки

* Обработчик `pointerdown` на документе — **в capture-фазе**, чтобы закрытие меню сработало до wheel-handlers.
* При этом в `onDown` колеса уже есть ранний выход по `isMenuOpen`, так что конфликтов не будет.

### 9) Выбор пункта — ближайший логический шаг

* Алгоритм уже есть: `idx + k*N, k∈{-1,0,1}` с минимальной дистанцией до `stepF`. Оставь, он корректный.
* Порядок действий: закрыть меню → `snapTo(best)` → остальное сделает текущее `onSelect`.

## Визуальные детали меню (оставить как предложено, но в наших токенах)

* Контейнер: `bg-[--glass-bg] border border-[--glass-border] backdrop-blur-[var(--glass-blur)] shadow-[var(--shadow-s)] rounded-[calc(var(--radius)*0.75)]`.
* Пункт: `px-4 py-3` (≈40–44px высота), слева иконка (`w-5 h-5`), затем текст `truncate`.
* Активный пункт: `bg-white/12 text-[--fg-strong]` + **тонкая золотая полоса слева** (`before:` или `border-l` c `--gold`). (Если оставишь точку справа — не критично, но полосу слева предпочтительнее.)
* Focus-visible: на лейбл-кнопке и пункте меню использовать `focus:[box-shadow:var(--ring)]` (из токенов).

## Accept/Definition of Done

* [ ] Лейбл кликабелен; клики реально попадают (не блокируются pointer-events).
* [ ] Меню открывается/закрывается (лейбл, вне клика, ESC); при открытом меню drag/свайп **не работает**.
* [ ] Выбор пункта закрывает меню и снапает колесо к выбранной секции с текущим haptic/звук-откликом; внешний скролл остаётся как прежде.
* [ ] Анимация меню работает без сторонних классов; при `prefers-reduced-motion` — без анимации.
* [ ] Нет регрессов: drag/снап/внешняя синхронизация прежние; нет «случайных» снапов при закрытии меню.
* [ ] Визуал и ARIA соответствуют описанию; нет «отрезания» поповера по `overflow` и проблем с `pointer-events`.

## Если по месту видишь, как сделать проще/надёжнее

* Предложи минимальный вариант (1–2 строки пояснения: что/почему/impact) и правь.

---

⚠️ Внеси **реальные изменения в код** в `FloatingChipWheel.jsx` по этому фикспаку. Если упрёшься в позиционирование поповера (из-за контекста z-index/overflow), предложи и реализуй перенос поповера в `document.body` через портал **без** сторонних библиотек (лаконичный внутренний портал-компонент), но только если без него не обойтись.
